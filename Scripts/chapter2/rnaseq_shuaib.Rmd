---
title: "RNAseq_analysis_covid19"
author: "Mukhtar Sadykov"
date: "11/22/2024"
---

# General overview

RNAseq read quality was assessed using FASTQC quality control tool [ref]. The reads were mapped to human GRCh38.p13 primary assembly using STAR (version 2.6.1) [ref]. Subsequently, gene counts were derived from the number of uniquely aligned unambiguous reads by Subread:featureCount (version v2.0.2) [ref] and library sizes were scale-normalized by the trimmed mean of M values (TMM) method using EdgeR software[ref]. The R package limma[ref] with the voomWithQualityWeights function [ref] was utilized to calculate the weighted likelihoods for all samples, based on the observed mean–variance relationship of every gene and sample. Genes with fold change greater than two and false discovery rate corrected p-value (Benjamini-Hochberg procedure) < 0.05 were considered to be differentially expressed.

## Preprocessing of a count table

Clean the environment, install the libraries and set working directory.
```{r}
rm(list=ls())
pacman::p_load(limma, Glimma, edgeR, AnnotationDbi,org.Hs.eg.db, EnsDb.Hsapiens.v86, tidyverse, ggplot2, ... = gridExtra, ggrepel, reshape2, EnhancedVolcano, GGally, sva, pheatmap, clusterProfiler, viridis, devtools, GeneSetCluster, readxl, gplots, ggpubr, wesanderson, factoextra)
setwd("~/Desktop/phd/Thesis/ch2/shuaib/")
```

Visualize MDS of the raw data 
```{r}
cts  <- read.csv("shuaib/counts.patients.csv", row.names = 1)

# remove Severe2,3,5,7,8
cts <- cts[, setdiff(colnames(cts), c("Severe2", "Severe3", "Severe5", "Severe7", "Severe8", "Mild46", "Mild47", "Mild2", "Healhty35"))]

#rownames <- row.names(cts)
study <- read.csv("shuaib/meta.csv", row.names=1) # dim is 106 x 1

cts <- cts[,row.names(study)]

## Remove low expression genes for batch analysis ##
## Do DEGs ##
raw <- edgeR::DGEList(counts=cts, samples=study)
sum(keep_raw <- edgeR::filterByExpr(raw, group=raw$samples$Class, min.count = 1))  ## 60672 -> 48617
raw <- raw[keep_raw, , keep.lib.sizes=TRUE]
# count matrix for BN
raw_cts <- raw$counts

mdf <- limma::plotMDS(cpm(raw, log=T), top=nrow(raw), plot=F, dim.plot = c(1,2), var.explained = TRUE)
mdf <- data.frame(Comp1=mdf$x, Comp2=mdf$y, 
      lab=colnames(raw), 
      ICU=raw$samples$Class,
      var.exp = mdf$var.explained)
p1 <- ggplot(mdf, aes(x = Comp1, y = Comp2, label = lab, col = ICU)) +
  geom_point(size = 7, alpha = 0.7) +  # Increase point size
  geom_text_repel(
    box.padding = 0.6,               # Increase padding for text
    point.padding = 0.5,             # Increase padding for points
    min.segment.length = 0.3,        # Adjust segment length
    size = 6                         # Increase text size
  ) +
  #scale_color_manual(values = c("Yes" = "#ECA39A", "No" = "#74CFD4")) +
  labs(
    x = paste0("Component 1 (var. explained ", round(mdf$var.exp[1], 2) * 100, "%)"),
    y = paste0("Component 2 (var. explained ", round(mdf$var.exp[2], 2) * 100, "%)")
  ) +
  theme_classic() +
  theme(
    axis.text.x = element_text(size = 20),  # Increase axis text size
    axis.text.y = element_text(size = 20),
    axis.title.y = element_text(size = 22),                                      # Increase axis title size
    axis.title.x = element_text(size = 22),
    axis.line = element_line(size = 1.2),                                        # Increase axis line thickness
    axis.ticks = element_line(size = 1.2),                                       # Thicken axis ticks
    legend.position = "right",
    legend.text = element_text(size = 20),                                       # Increase legend text size
    legend.title = element_text(size = 20)                                       # Increase legend title size
  )


## add genes 
ensg <- sub("\\..*", "", rownames(raw_cts))  # remove version number in case you have it
sym <- AnnotationDbi::mapIds(EnsDb.Hsapiens.v86, keys=ensg,
        column="SYMBOL", keytype="GENEID") # Unable to map 1023 of 27147 requested IDs.
gene <- data.frame(ENSGID=ensg, SYMBOL=sym, stringsAsFactors=F)
rownames(gene) <- rownames(raw_cts)

```

## Make DGEList

```{r}
# Check point of the dimensions of datasets
stopifnot( identical( colnames(raw_cts), rownames(study) ) )
stopifnot( identical( rownames(raw_cts), rownames(gene) ) )

raw <- edgeR::DGEList(counts=raw_cts, samples=study, genes=gene)
```

## Check for seq. bias
```{r}
# Check for bias in sequencing depth by KO types.
p<-ggplot(raw$samples, aes(x=ICU, y=lib.size/1000000)) + 
  geom_violin(trim=FALSE)+geom_boxplot(width=0.1) + theme_minimal()+ ggtitle("Sequencing library size (millions)")

p <- p + geom_dotplot(binaxis='y', stackdir='center', dotsize=1)


df<-data.frame(colnames(raw$counts), row.names(raw$samples), raw$samples$lib.size)
write.csv(df, "~/Desktop/phd/Thesis/ch2/shuaib/library_sizes_IDs.csv")
```

## Filter

To filter the low expression genes the edgeR's filterByExpr() was used.
Default min number of reads to keep is 10.
```{r}
sum(keep <- edgeR::filterByExpr(raw, group=raw$samples$Class))  ## 60663 -> 36674 
```

```{r}
raw_filtered <- raw[keep, , keep.lib.sizes=FALSE]

write.csv(data.frame(raw_filtered$counts, raw_filtered$genes), "~/Desktop/phd/Thesis/ch2/shuaib/raw_filtered.csv")
```
After changing the number of genes from 60663 to 28611, the lib.sizes will be recalculated to be the sum of the counts left in the rows of the experiment for each sample, with keep.lib.sizes = FALSE

Plot the intensities before and after filtering
```{r}
tmp <- edgeR::cpm(raw_filtered$counts) %>% melt
g.after <- ggplot(tmp, aes(value, col=Var2)) + geom_density() + 
  ggtitle("After filtering") + theme_bw() + theme(legend.position="none") 

#grid.arrange(g.before, g.after, nrow=1)

rm( list=setdiff(ls(), c("raw_filtered", "study")) )
```

## Normalization

The edgeR function calcNormFactors was used to generate and apply normalization factors. By default, the M-values are weighted according to inverse variances, as computedby the delta method for logarithms of binomial random variables. If refColumn is unspecified, then the library whose upper quartile is closest to the mean upper quartile is used.
```{r}
# Calculate normalization factors to scale the raw library sizes.
norm <- edgeR::calcNormFactors(raw_filtered, method="TMM")


nf <- norm$samples$norm.factors # for each sample
range(nf) # 0.04920284 to 2.03409633
o <- order(nf)

boxplot( cpm(raw_filtered[ , o], log=T), xaxt="n", main="Before TMM normalization")
boxplot( cpm(norm[ , o], log=T),   xaxt="n", main="After TMM normalization")

plot( norm$samples$norm.factors[o],  xaxt="n", main="Normalization factor", xlab="" )
save(norm, file="~/Desktop/phd/Thesis/ch2/shuaib/norm.rda", compress=TRUE)
#save(batch_norm, file="~/Desktop/rnaseq/last/batch_norm.rda", compress=TRUE)
```


## Analyze gender
```{r}
# Load required libraries
library(ggplot2)
library(tidyr)
library(dplyr)

# Gender specific genes
#  RPS4Y1 and XIST, which are specifically expressed in males and females respectively
# source: https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-021-04307-0#Sec1
# ENSG00000229807 and ENSG00000129824

# Assuming your data frame is called 'expression_data'
# with ENSEMBL IDs as row names and sample names as column names

analyze_gender <- function(expression_data) {
  # Extract expression values for gender-specific genes
  xist_expr <- expression_data["ENSG00000229807", ]
  rps4y1_expr <- expression_data["ENSG00000129824", ]
  
  # Create a data frame for plotting
  plot_data <- data.frame(
    sample = names(xist_expr),
    XIST = as.numeric(xist_expr),
    RPS4Y1 = as.numeric(rps4y1_expr)
  )
  
  # Calculate log2 of expression values (adding small constant to avoid log(0))
  plot_data$log2_XIST <- log2(plot_data$XIST + 0.1)
  plot_data$log2_RPS4Y1 <- log2(plot_data$RPS4Y1 + 0.1)
  
  # Determine gender based on expression ratios
  plot_data$predicted_gender <- ifelse(
    plot_data$log2_XIST > plot_data$log2_RPS4Y1,
    "Female",
    "Male"
  )
  
  # Create scatter plot
  p1 <- ggplot(plot_data, aes(x = log2_XIST, y = log2_RPS4Y1, color = predicted_gender)) +
    geom_point(size = 3, alpha = 0.7) +
    theme_minimal() +
    labs(
      x = "log2(XIST Expression)",
      y = "log2(RPS4Y1 Expression)",
      title = "Gender Prediction based on XIST and RPS4Y1 Expression",
      color = "Predicted Gender"
    ) +
    scale_color_manual(values = c("Female" = "#FF69B4", "Male" = "#4169E1")) +
    theme(
      plot.title = element_text(hjust = 0.5, size = 12),
      legend.position = "bottom"
    )
  
  # Create density plots
  plot_data_long <- pivot_longer(plot_data, 
                                cols = c("log2_XIST", "log2_RPS4Y1"),
                                names_to = "gene",
                                values_to = "expression")
  
  p2 <- ggplot(plot_data_long, aes(x = expression, fill = gene)) +
    geom_density(alpha = 0.5) +
    facet_wrap(~predicted_gender) +
    theme_minimal() +
    labs(
      x = "log2(Expression)",
      y = "Density",
      title = "Distribution of Gender-Specific Gene Expression",
      fill = "Gene"
    ) +
    scale_fill_manual(
      values = c("log2_XIST" = "#FF69B4", "log2_RPS4Y1" = "#4169E1"),
      labels = c("XIST", "RPS4Y1")
    ) +
    theme(
      plot.title = element_text(hjust = 0.5, size = 12),
      legend.position = "bottom"
    )
  
  # Return results
  return(list(
    predictions = plot_data,
    scatter_plot = p1,
    density_plot = p2
  ))
}

# Example usage:
# results <- analyze_gender(expression_data)
# print(results$scatter_plot)
# print(results$density_plot)
# View(results$predictions)
```

```{r}
cts <-norm$counts

results <- analyze_gender(cts)

# View the plots
pdf(file="~/Desktop/phd/Thesis/ch2/shuaib/gender_scatter_plot.pdf", height=5, width=5)
print(results$scatter_plot)
dev.off()

pdf(file="~/Desktop/phd/Thesis/ch2/shuaib/gender_density_plot.pdf", height=5, width=5)
print(results$density_plot)
dev.off()

# Get predictions
predictions <- results$predictions
write.csv(file ="~/Desktop/phd/Thesis/ch2/shuaib/gender_predictions.csv", predictions)
```


## DEGs
```{r}
#study_outlier <- read.delim("meta_outlier.txt", row.names=1)
mm <- model.matrix( ~ 0 + Class, data=norm$samples)

#mm <- model.matrix( ~ 0 + ICU, data=batch_norm$samples)
colnames(mm) <- gsub("Class", "", colnames(mm))
#colnames(mm) <- gsub("BatchBatch", "Batch", colnames(mm))
#head(mm,10)

```

## Limma-voom
Allows for incredibly flexible model specification (you can include multiple categorical and continuous variables, allowing incorporation of almost any kind of metadata)

Based on simulation studies, maintains the false discovery rate at or below the nominal rate, unlike some other packages

The above specifies a model where each coefficient corresponds to a KO's mean

```{r}
vm <- limma::voomWithQualityWeights(norm, design=mm, plot=T)
#vm <- limma::voomWithQualityWeights(batch_norm, design=mm, plot=T)
save(vm, file="~/Desktop/phd/Thesis/ch2/shuaib/vm_norm.rda", compress=TRUE)
#load("vm.rda")
```
What is voom doing?

Counts are transformed to log2 counts per million reads (CPM), where “per million reads” is defined based on the normalization factors we calculated earlier
A linear model is fitted to the log2 CPM for each gene, and the residuals are calculated
A smoothed curve is fitted to the sqrt(residual standard deviation) by average expression (see red line in plot above)
The smoothed curve is used to obtain weights for each gene and sample that are passed into limma along with the log2 CPMs.
More details at https://urldefense.com/v3/__https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29__;!!Nmw4Hv0!ycgzUCXcFHGhQEnI2H47axDZcJtl7u1xv3mdW2lj-zw3lXmUe2fAPNVM9_db1ABe3hR1QDHrBz5cdvOgBfnGAV0a7_-IGozu-kLL8LEHEdV9$ 


Another handy feature of limma-voom  is easy to make contrast matrices
## Contrast matrix
```{r}
cm <- limma::makeContrasts(
  KRvsHEALTHY = KR_Patient - Healthy,
  NonKRvsHEALTHY = NonKR_Patient - Healthy,
  KRvsNonKR = KR_Patient - NonKR_Patient,
  levels= mm )
```

## Fitting eBayes
### Empirical Bayes Statistics for Differential Expression
### Given a microarray linear model fit, compute moderated t-statistics, moderated F-statistic, and log-odds of differential expression by empirical Bayes moderation of the standard errors towards a common value.

Empirical Bayes smoothing of gene-wise standard deviations provides increased power.
```{r}
fit <- limma::lmFit(vm[ , rownames(mm) ], mm) # lmFit fits a linear model using weighted least squares for each gene
fit <- limma::contrasts.fit(fit, cm) # Estimate contrast for each gene
fit <- limma::eBayes(fit, trend=TRUE) # Empirical Bayes smoothing of standard errors (shrinks standard errors that are much larger or smaller than those from other genes towards the average standard error) (see https://urldefense.com/v3/__https://www.degruyter.com/doi/10.2202/1544-6115.1027__;!!Nmw4Hv0!ycgzUCXcFHGhQEnI2H47axDZcJtl7u1xv3mdW2lj-zw3lXmUe2fAPNVM9_db1ABe3hR1QDHrBz5cdvOgBfnGAV0a7_-IGozu-kLL8Nt1J23i$ )
```

## Summary tables for H1 KOs

Identify which genes are significantly differentially expressed for each contrast from a fit object containing p-values and test statistics. 
```{r}
summary(limma::decideTests(fit)) # Default p valut is 0.05.
```

Some studies require more than an adjusted p-value cut-off. For a stricter definition on significance, one may require log-fold-changes (log-FCs) to be above a minimum value.

Here we introduced three significance level to the topTable: sig0, sig1 and sig2.
sig0's -1 means that the gene is significantly downregulated (see parameters in the code); sig0's +1 meand that the gene is significantly upregulated (see parameters in the code);
sig1 and sig2 values are even stricter.

## Toptable

```{r}
# Created two significance levels: sig and sig2. Sig based on FC and FDR.
tt1 <- topTable(fit, coef="KRvsHEALTHY", adjust.method="fdr", n=Inf) %>% 
  rownames_to_column("ID") %>% 
  arrange(P.Value) %>% 
  mutate(sig0  = sign(logFC)*( abs(logFC) > log2(1.5) & adj.P.Val < 0.05 ),
   sig1  = sign(logFC)*( abs(logFC) > log2(2) & adj.P.Val < 0.05 ),
   sig2 = sign(logFC)*( abs(logFC) > log2(4) & adj.P.Val < 0.01 )) %>% 
  dplyr::select(ID, ENSGID, SYMBOL, 
    KRvsHEALTHY_LFC=logFC, KRvsHEALTHY_P=P.Value, KRvsHEALTHY_FDR=adj.P.Val, KRvsHEALTHY_sig0=sig0, KRvsHEALTHY_sig1=sig1,KRvsHEALTHY_sig2=sig2)

tt2 <- topTable(fit, coef="NonKRvsHEALTHY", adjust.method="fdr", n=Inf) %>% 
  rownames_to_column("ID") %>% 
  arrange(P.Value) %>% 
  mutate(sig0  = sign(logFC)*( abs(logFC) > log2(1.5) & adj.P.Val < 0.05 ),
   sig1  = sign(logFC)*( abs(logFC) > log2(2) & adj.P.Val < 0.05 ),
   sig2 = sign(logFC)*( abs(logFC) > log2(4) & adj.P.Val < 0.01 )) %>% 
  dplyr::select(ID, ENSGID, SYMBOL, 
    NonKRvsHEALTHY_LFC=logFC, NonKRvsHEALTHY_P=P.Value, NonKRvsHEALTHY_FDR=adj.P.Val, NonKRvsHEALTHY_sig0=sig0, NonKRvsHEALTHY_sig1=sig1,NonKRvsHEALTHY_sig2=sig2)

tt3 <- topTable(fit, coef="KRvsNonKR", adjust.method="fdr", n=Inf) %>% 
  rownames_to_column("ID") %>% 
  arrange(P.Value) %>% 
  mutate(sig0  = sign(logFC)*( abs(logFC) > log2(1.5) & adj.P.Val < 0.05 ),
   sig1  = sign(logFC)*( abs(logFC) > log2(2) & adj.P.Val < 0.05 ),
   sig2 = sign(logFC)*( abs(logFC) > log2(4) & adj.P.Val < 0.01 )) %>% 
  dplyr::select(ID, ENSGID, SYMBOL, 
    KRvsNonKR_LFC=logFC, KRvsNonKR_P=P.Value, KRvsNonKR_FDR=adj.P.Val, KRvsNonKR_sig0=sig0, KRvsNonKR_sig1=sig1,KRvsNonKR_sig2=sig2)


tt <- BiocGenerics::Reduce(plyr::join, list(tt1, tt2, tt3))

# add the symbols to tt
gene <- read.csv("~/Desktop/phd/Thesis/ch2/mart_export.txt",  sep = "\t")
gene <- gene[,c(1, 3, 5)]
gene <- gene %>% distinct()

tt <- merge(gene, tt, by="ID", all.y = TRUE)
#names(tt)[names(tt) == 'SYMBOL.x'] <- 'SYMBOL'
tt <- dplyr::mutate(tt, KRvsHEALTHY_LFC_ABS=abs(tt$KRvsHEALTHY_LFC))
tt <- dplyr::mutate(tt, NonKRvsHEALTHY_LFC_ABS=abs(tt$NonKRvsHEALTHY_LFC))
tt <- dplyr::mutate(tt, KRvsNonKR_LFC_ABS=abs(tt$KRvsNonKR_LFC))

rm(list=setdiff(ls(), c("norm", "tt", "vm", "study")))

# save tt
write.csv(tt, file="~/Desktop/phd/Thesis/ch2/shuaib/topTable_all.csv")

tt_sig <- dplyr::filter(tt, KRvsHEALTHY_FDR <0.05 & KRvsHEALTHY_LFC_ABS > 0.667) #0.667 is 1.5 FC
write.csv(tt_sig, file="~/Desktop/phd/Thesis/ch2/shuaib/topTable_sig1_KRvsHEALTHY.csv")
tt_sig2 <- dplyr::filter(tt, KRvsHEALTHY_FDR <0.01 & KRvsHEALTHY_LFC_ABS > 1) # 2 FC
write.csv(tt_sig2, file="~/Desktop/phd/Thesis/ch2/shuaib/topTable_sig2_KRvsHEALTHY.csv")

tt_sig <- dplyr::filter(tt, NonKRvsHEALTHY_FDR <0.05 & NonKRvsHEALTHY_LFC_ABS > 0.667) #0.667 is 1.5 FC
write.csv(tt_sig, file="~/Desktop/phd/Thesis/ch2/shuaib/topTable_sig1_KRvsHEALTHY.csv")
tt_sig2 <- dplyr::filter(tt, NonKRvsHEALTHY_FDR <0.01 & NonKRvsHEALTHY_LFC_ABS > 1) # 2 FC
write.csv(tt_sig2, file="~/Desktop/phd/Thesis/ch2/shuaib/topTable_sig2_NonKRvsHEALTHY.csv")

tt_sig <- dplyr::filter(tt, KRvsNonKR_FDR <0.05 & KRvsNonKR_LFC_ABS > 0.667) #0.667 is 1.5 FC
write.csv(tt_sig, file="~/Desktop/phd/Thesis/ch2/shuaib/topTable_sig1_KRvsNonKR.csv")
tt_sig2 <- dplyr::filter(tt, KRvsNonKR_FDR <0.01 & KRvsNonKR_LFC_ABS > 1) # 2 FC
write.csv(tt_sig2, file="~/Desktop/phd/Thesis/ch2/shuaib/topTable_sig2_KRvsNonKR.csv")
```


## Volcano plots

```{r}
pdf(file="~/Desktop/phd/Thesis/ch2/shuaib/volcano_plots_FDR_001_11.pdf", height=10, width=10)

lfc_tmp <- max( -log10(tt$KRvsHEALTHY_FDR) )
EnhancedVolcano(tt,
                lab = NA, # Optional: Replace NA with tt$SYMBOL if you want labels for genes
                x = "KRvsHEALTHY_LFC", # Log2 Fold Change column
                y = "KRvsHEALTHY_FDR", # Adjusted p-value (FDR) column
                pCutoff = 0.05,     # Set the cutoff for adjusted p-value (q-value < 0.05)
                #subtitle = "ICU vs non-ICU COVID-19 patients",
                FCcutoff = 1.5,     # Set the cutoff for log2-fold change (log2 FC > 1.5)
                ylim = c(0, lfc_tmp + 1),  # Adjust y-axis limit
                ylab = bquote(~-Log[10] ~ italic("adjusted p-value")),
                title = "",
                colAlpha = 0.3,
                selectLab = c(),    # Specify any gene symbols to label, or leave blank
                drawConnectors = FALSE  # Set to TRUE if you want connectors for labeled points
) +
  theme(
    legend.position = "none",    # Remove legend
    axis.title = element_text(size = 14),  # Increase axis title size
    axis.text = element_text(size = 12),   # Increase axis text size
    plot.title = element_text(size = 16, face = "bold")  # Increase title size and bold it
  )

dev.off()


```

## The list of genes that are Up or Down regulated. 
```{r}
# Function to write a table
mywrite <- function(...){
  write.table(..., row.names=F, col.names=F, quote=F)
}

tt %>% dplyr::filter(ICUvsNON_sig0==1) %>% arrange(ICUvsNON_LFC) %>% 
  pull(ENSGID) %>% mywrite(file="~/Desktop/phd/Thesis/ch2/siglist_ICUvsNON_sig0_up_11.txt")
tt %>% dplyr::filter(ICUvsNON_sig0==-1) %>% arrange(ICUvsNON_LFC) %>% 
  pull(ENSGID) %>% mywrite(file="~/Desktop/phd/Thesis/ch2/siglist_ICUvsNON_sig0_down_11.txt")

tt %>% dplyr::filter(ICUvsNON_sig1==1) %>% arrange(ICUvsNON_LFC) %>% 
  pull(ENSGID) %>% mywrite(file="~/Desktop/phd/Thesis/ch2/siglist_ICUvsNON_sig1_up_11.txt")
tt %>% dplyr::filter(ICUvsNON_sig1==-1) %>% arrange(ICUvsNON_LFC) %>% 
  pull(ENSGID) %>% mywrite(file="~/Desktop/phd/Thesis/ch2/siglist_ICUvsNON_sig1_down_11.txt")

tt %>% dplyr::filter(ICUvsNON_sig2==1) %>% arrange(ICUvsNON_LFC) %>% 
  pull(ENSGID) %>% mywrite(file="~/Desktop/phd/Thesis/ch2/siglist_ICUvsNON_sig2_up_11.txt")
tt %>% dplyr::filter(ICUvsNON_sig2==-1) %>% arrange(ICUvsNON_LFC) %>% 
  pull(ENSGID) %>% mywrite(file="~/Desktop/phd/Thesis/ch2/siglist_ICUvsNON_sig2_down_11.txt")
```

## Heatmap and number of clusters batch normalized data

```{r}
save_pheatmap_pdf <- function(x, filename, width=12, height=9) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}

# Reodered study according to heatmap clustering
#study <- read.csv("~/Desktop/rnaseq/last/raw/80s_new_metadata/meta_80s.csv", row.names = 1)

lcpm <- cpm(norm, log=TRUE)

topTable.topgenes <- tt_sig2$ID
i <- which(vm$genes$ENSGID %in% topTable.topgenes)
mycol <- colorRampPalette(c("blue","white","red"))(20)

#annotation info
annotation <- data.frame(seq(1:102),study$Class, row.names = 1)
colnames(annotation) <- gsub("study.", "", colnames(annotation))
rownames(annotation) <- colnames(lcpm) # check out the row names of annotation
##colors

ann_colors = list(
    ICU = c(KR_Patient="#F2300F", NonKR_Patient="#972D15", Healthy ="#D8B70B")
)
#annotation <- annotation[, c("ICU", "Outcome", "Age", "Hospital", "Gender", "Comorbidities")]

heatmap1 <- pheatmap(lcpm[i,], cluster_cols = T, cluster_rows = T,
                     scale = "row", #kmeans_k = 20,
                     cutree_rows = 2, cutree_cols = 2,
                     color = colorRampPalette(c("blue", "white", "red"))(20),
                     show_rownames = 0, annotation_col = annotation, 
                     #cellwidth = 8, cellheight = 8, border_color = "black",
                     annotation_colors = ann_colors, #labels_col=study$AltName, 
                     treeheight_row=0
                     )
save_pheatmap_pdf(heatmap1, "~/Desktop/phd/Thesis/ch2/shuaib/Heatmap_annotation_clustered.pdf")

heatmap1 <- pheatmap(lcpm[i,], cluster_cols = F, cluster_rows = T,
                     scale = "row", #kmeans_k = 20,
                     cutree_rows = 2, cutree_cols = 2,
                     color = colorRampPalette(c("blue", "white", "red"))(20),
                     show_rownames = 0, annotation_col = annotation, 
                     #cellwidth = 8, cellheight = 8, border_color = "black",
                     annotation_colors = ann_colors, #labels_col=study$AltName, 
                     treeheight_row=0
                     )
save_pheatmap_pdf(heatmap1, "~/Desktop/phd/Thesis/ch2/shuaib/Heatmap_annotation_ordered.pdf")

# Since we are comparing gene expression patterns we need to scale the data otherwise all of the highly expressed genes will cluster together even if they have different patterns among the samples. The function scale scales collumns. So to scale per gene (rows) data needs to be transposed.
#library(factoextra)

#DEgenes <- as.matrix(lcpm[i,])
#scaledata <- t(scale(t(DEgenes)))

#s1 <- fviz_nbclust(scaledata, FUN = hcut, method = "silhouette")


#Re-order original data (genes) to match ordering in heatmap (top-to-bottom)
rownames(lcpm[heatmap1$tree_row[["order"]],])
#Re-order original data (samples) to match ordering in heatmap (left-to-right)
#colnames(lcpm[,heatmap1$tree_col[["order"]]]) # turn on the clstur cols in pheatmap

#If you want something like gene-to-cluster assignment, you can 'cut' your row dendrogram into a pre-selected number of groups as follows:

#2 groups
two_clusters <- sort(cutree(heatmap1$tree_row, k=2))
print(table(two_clusters))
two_clusters <- t(data.frame(as.list(two_clusters)))
ID <- row.names(two_clusters)
two_clusters <- data.frame(ID, two_clusters)
 
write.csv(two_clusters, '~/Desktop/phd/Thesis/ch2/shuaib/two_clusters_heatmap.csv')

```

## Prepare cts for cell deconvolution
```{r}
# Function to fix Excel date-formatted gene names
fix_date_gene_names <- function(gene_names) {
  # Create conversion dictionary
  date_to_gene <- c(
    "1-DEC" = "DEC1",
    "1-Dec" = "DEC1",
    "2-DEC" = "DEC2",
    "2-Dec" = "DEC2",
    "1-MAR" = "MARCH1",
    "1-Mar" = "MARCH1",
    "2-MAR" = "MARCH2",
    "2-Mar" = "MARCH2",
    "3-MAR" = "MARCH3",
    "3-Mar" = "MARCH3",
    "4-MAR" = "MARCH4",
    "4-Mar" = "MARCH4",
    "5-MAR" = "MARCH5",
    "5-Mar" = "MARCH5",
    "6-MAR" = "MARCH6",
    "6-Mar" = "MARCH6",
    "7-MAR" = "MARCH7",
    "7-Mar" = "MARCH7",
    "8-MAR" = "MARCH8",
    "8-Mar" = "MARCH8",
    "9-MAR" = "MARCH9",
    "9-Mar" = "MARCH9",
    "10-MAR" = "MARCH10",
    "10-Mar" = "MARCH10",
    "11-MAR" = "MARCH11",
    "11-Mar" = "MARCH11",
    "1-SEP" = "SEPT1",
    "1-Sep" = "SEPT1",
    "2-SEP" = "SEPT2",
    "2-Sep" = "SEPT2",
    "3-SEP" = "SEPT3",
    "3-Sep" = "SEPT3",
    "4-SEP" = "SEPT4",
    "4-Sep" = "SEPT4",
    "5-SEP" = "SEPT5",
    "5-Sep" = "SEPT5",
    "6-SEP" = "SEPT6",
    "6-Sep" = "SEPT6",
    "7-SEP" = "SEPT7",
    "7-Sep" = "SEPT7",
    "8-SEP" = "SEPT8",
    "8-Sep" = "SEPT8",
    "9-SEP" = "SEPT9",
    "9-Sep" = "SEPT9",
    "10-SEP" = "SEPT10",
    "10-Sep" = "SEPT10",
    "11-SEP" = "SEPT11",
    "11-Sep" = "SEPT11",
    "12-SEP" = "SEPT12",
    "12-Sep" = "SEPT12",
    "13-SEP" = "SEPT13",
    "13-Sep" = "SEPT13",
    "14-SEP" = "SEPT14",
    "14-Sep" = "SEPT14"
  )
  
  # Function to fix a single gene name
  fix_single_name <- function(name) {
    if (name %in% names(date_to_gene)) {
      return(date_to_gene[name])
    }
    return(name)
  }
  
  # Fix all gene names
  fixed_names <- sapply(gene_names, fix_single_name)
  
  # Return fixed names with same attributes as input
  if (is.factor(gene_names)) {
    fixed_names <- factor(fixed_names)
  }
  
  return(fixed_names)
}

# Example usage:
# If your data is in a data frame called 'expression_data':
# expression_data$gene_names <- fix_date_gene_names(expression_data$gene_names)

# If gene names are rownames:
# rownames(expression_data) <- fix_date_gene_names(rownames(expression_data))

# To check which names were changed:
check_changed_names <- function(original_names) {
  fixed_names <- fix_date_gene_names(original_names)
  changed <- which(original_names != fixed_names)
  if (length(changed) > 0) {
    changes <- data.frame(
      Original = original_names[changed],
      Fixed = fixed_names[changed]
    )
    print("Changed names:")
    print(changes)
  } else {
    print("No date-formatted gene names found")
  }
}

lcpm <- cpm(norm, log=FALSE)


# for cibersortx analysis
tt_genes <- read.csv("../ch2/shuaib/topTable_all.csv", row.names = 1)
tt_genes <- tt_genes[, c("ENSGID","SYMBOL")]

cts_ciber <- merge(tt_genes, lcpm, by = 0)
cts_ciber <- cts_ciber[, 3:length(cts_ciber)]
cts_ciber <- cts_ciber[!duplicated(cts_ciber$SYMBOL), ]
cts_ciber <- cts_ciber[!duplicated(cts_ciber$SYMBOL) & complete.cases(cts_ciber), ]

row.names(cts_ciber) <- cts_ciber$SYMBOL
cts_ciber <- cts_ciber[,2:length(cts_ciber)]

# Fix gene names in rownames
rownames(cts_ciber) <- fix_date_gene_names(rownames(cts_ciber))


write.csv(cts_ciber, "~/Desktop/phd/Thesis/ch2/shuaib/lcpm_for_cibersortx.csv")
write.table(cts_ciber, "~/Desktop/phd/Thesis/ch2/shuaib/lcpm_for_cibersortx.txt", sep = "\t",
            quote = FALSE)



## PLot PCA PLOT of Cell Proportions

# PCA for cell proportions #

a6 <- read.csv("~/Desktop/phd/Thesis/ch2/shuaib/for_pca_cell_deconvolution_plotting.csv", header = T)

a6.pca <- prcomp(a6[,c(3:25)], 
                   center = TRUE, 
                   scale. = TRUE) 

# summary of the  
# prcomp object 
summary(a6.pca)
# loading library 
library(ggfortify) 
icu_nonICU.plot <- autoplot(a6.pca, 
                            data = a6, 
                            colour = 'Severity') 
icu_nonICU.plot
#ggsave("~/Desktop/dnam/rnaseq/cybersortX/all_bRNA_samples_80/pca_icuVSnonicu.pdf", icu_nonICU.plot, dpi = 300, width = 10, height = 10) 

# Load necessary libraries
library(ggfortify)
library(ggplot2)

# Generate the PCA plot with larger fonts and enhanced style
icu_nonICU.plot <- autoplot(a6.pca, 
                            data = a6, 
                            colour = 'Severity',
                            size = 4) +
  theme_minimal() +  # Cleaner background
  theme(
    text = element_text(size = 14),  # Increase font size
    axis.title = element_text(size = 16, face = "bold"),  # Axis title size and boldness
    axis.text = element_text(size = 14),  # Axis text size
    legend.title = element_text(size = 14),  # Legend title size
    legend.text = element_text(size = 12),  # Legend text size
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)  # Centered and bold title
  ) +
  labs(
    #title = "PCA Plot: ICU vs Non-ICU",  # Add a title
    #x = "Principal Component 1",         # Customize x-axis label
    #y = "Principal Component 2",         # Customize y-axis label
    colour = "Group"                     # Customize legend title
  ) +
  scale_color_manual(values = c("#00ff20", "#0073C2FF", "#FF1000"))  # Customize color palette

# Print the plot
print(icu_nonICU.plot)
ggsave("~/Desktop/phd/Thesis/ch2/shuaib/pca_icuVSnonicu_shuaib.pdf", 
       icu_nonICU.plot, dpi = 300, width = 8, height = 5) 


##########################################################################
#########   CALCULATE STATS ##############################################
##########################################################################

# upload the cell deconvoluted df
data <- a6[ ,c(2:25)]
data <- data[order(data$Severity,decreasing=TRUE),] # ICU group: Yes, No and the cell proportions

# Split the data into ICU and NON groups
severe_data <- subset(data, grepl("^Severe", Severity))
healthy_data <- subset(data, grepl("^Healthy", Severity))
mild_data <- subset(data, grepl("^Mild", Severity))


##### Severe vs Mild #####
# Create an empty list to store results
results_list <- list()

# Perform Wilcoxon rank sum test for each variable and store results in the list
variables <- colnames(data[,2:24])

for (variable in variables) {
  test_result <- wilcox.test(severe_data[[variable]], mild_data[[variable]])
  results_list[[variable]] <- c(variable, test_result$statistic, test_result$p.value)
}

# Convert the list to a data frame
results_df <- as.data.frame(do.call(rbind, results_list), stringsAsFactors = FALSE, row.names = 0)
# Set correct column names
colnames(results_df) <- c("Variable", "W_statistic", "p_value")
# Adjust p-values using Benjamini-Hochberg method
results_df$adjusted_p_value <- p.adjust(results_df$p_value, method = "BH")
write.csv(results_df, "~/Desktop/phd/Thesis/ch2/shuaib/stats_cellDeconvolution_wilcoxonText_severeVSmild.csv")


##### Severe vs Healthy #####
# Create an empty list to store results
results_list <- list()

# Perform Wilcoxon rank sum test for each variable and store results in the list
variables <- colnames(data[,2:24])

for (variable in variables) {
  test_result <- wilcox.test(severe_data[[variable]], healthy_data[[variable]])
  results_list[[variable]] <- c(variable, test_result$statistic, test_result$p.value)
}

# Convert the list to a data frame
results_df <- as.data.frame(do.call(rbind, results_list), stringsAsFactors = FALSE, row.names = 0)
# Set correct column names
colnames(results_df) <- c("Variable", "W_statistic", "p_value")
# Adjust p-values using Benjamini-Hochberg method
results_df$adjusted_p_value <- p.adjust(results_df$p_value, method = "BH")

# save the results data frame
write.csv(results_df, "~/Desktop/phd/Thesis/ch2/shuaib/stats_cellDeconvolution_wilcoxonText.csv")

ordered_stats <- results_df[order(results_df$adjusted_p_value,decreasing=FALSE),]

# melt - to reshape and elongate the data frames in a user-defined manner
# cast is oposite to cast, it takes long-format data and casts it into wide-format data
dat.m = melt(data, id.var=c("Severity"))
# Filter dataframe to include only rows where the 'Name' column matches the name_vector
filtered_df <- dat.m %>%
  filter(variable %in% ordered_stats$Variable[1:10])

filtered_df <- filtered_df %>%
  mutate(variable = factor(variable, levels = ordered_stats$Variable[1:10]))

ggplot(filtered_df, aes(x=Severity, y=value, fill=variable)) + 
  geom_boxplot() +
  facet_wrap(~variable, scale="free", ncol=4, strip.position = "left")

# Create the plot with wrapped text in facet labels
library(ggplot2)
library(dplyr)
library(ggpubr)  # For adding statistical significance

# Assuming filtered_df is your dataframe
ggplot(filtered_df, aes(x = Severity, y = value, fill = variable)) +
  geom_boxplot(outlier.shape = NA, width = 0.7) +  # More compact boxplots and hiding outliers
  facet_wrap(~variable, scales = "free", ncol = 5, strip.position = "left") +
  theme_minimal(base_size = 14) +  # Clean theme with larger base font
  theme(
    strip.text = element_text(size = 13, face = "bold"),  # Larger facet labels with bold text
    axis.text.x = element_text(size = 12, angle = 90, hjust = 1),  # Larger and rotated x-axis labels
    axis.text.y = element_text(size = 12),  # Larger y-axis labels
    axis.title.x = element_text(size = 16),  # Larger x-axis title
    axis.title.y = element_text(size = 16),  # Larger y-axis title
    legend.position = "none",  # Remove legend for compactness
    panel.spacing = unit(0.5, "lines"),  # Reduce spacing between panels
    strip.placement = "outside",  # Place facet labels outside the plot
    plot.margin = unit(c(0.1, 1, 1, 1), "cm"),  # Add margins around the plot
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.7)  # Add black border/frame around plots
  ) +
  labs(x = NULL, y = NULL) +
  scale_fill_brewer(palette = "Set3") +  # Use a nicer color palette
  stat_compare_means(
    aes(group = Severity),  # Grouping by ICU/non-ICU
    method = "wilcox.test",  # Choose appropriate test, e.g., t.test or wilcox.test
    label = "p.signif",  # Add stars for significance
    label.y = max, # Position at the top of the plot
    step.increase = 0.1, # Adjust the height of brackets
    vjust = 0.5,
    bracket.size = 10,
    hide.ns = TRUE  # Hide 'not significant' markers
  )

ggsave("~/Desktop/phd/Thesis/ch2/shuaib/boxplots_cellDeconv_withStats_severeVSmild.pdf", width = 10,
       height = 10)
```


## Heatmap of apobecs

```{r}
save_pheatmap_pdf <- function(x, filename, width=9, height=11) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}

lcpm <- edgeR::cpm(norm, log=TRUE)

tt_apobecs <- dplyr::filter(tt, str_detect(SYMBOL, "APOBEC") & !str_detect(SYMBOL, "APOBEC3B-AS1"))

topTable.topgenes <- tt_apobecs$ID
i <- which(vm$genes$ENSGID %in% topTable.topgenes)
mycol <- colorRampPalette(c("blue","white","red"))(20)

#annotation info
annotation <- data.frame(seq(1:102),study$Class, row.names = 1)
colnames(annotation) <- gsub("study.", "", colnames(annotation))
rownames(annotation) <- colnames(lcpm) # check out the row names of annotation
##colors

ann_colors = list(
    ICU = c(KR_Patient="#F2300F", NonKR_Patient="#972D15", Healthy ="#D8B70B"))

heatmap1 <- pheatmap(lcpm[i,], cluster_cols = F, cluster_rows = T,
                     scale = "row", #kmeans_k = 20,
                     cutree_rows = 3, cutree_cols = 2,
                     color = colorRampPalette(c("blue", "white", "red"))(50),
                     show_rownames = 1, annotation_col = annotation, 
                     cellwidth = 7, cellheight = 7, border_color = "black",
                     labels_col=study$ID, annotation_colors = ann_colors,
                     treeheight_row=0, labels_row = vm$genes$SYMBOL[i],annotation_legend = FALSE
                     )

save_pheatmap_pdf(heatmap1, "~/Desktop/phd/Thesis/ch2/shuaib/heatmap_apobecs_3.pdf", width = 12, height = 8)
```

```{r}
# Create a named vector to map Ensembl IDs to symbols
gene_symbols <- tt_apobecs$SYMBOL
names(gene_symbols) <- tt_apobecs$ID

# Extract APOBEC expression values
apobec_data <- lcpm[i,] %>% 
  as.data.frame() %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Sample") %>%
  mutate(Group = study$Class) 

# Reshape to long format and replace Ensembl IDs with symbols
apobec_long <- apobec_data %>%
  pivot_longer(cols = -c(Sample, Group),
              names_to = "Gene",
              values_to = "Expression") %>%
  mutate(Gene = gene_symbols[Gene])  # Replace IDs with symbols

# Create the plot
ggplot(apobec_long, aes(x = Gene, y = Expression, fill = Group)) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(0.8), alpha = 0.5) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8),
              aes(color = Group), size = 2) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14),  # Increased x-axis text size
        axis.text.y = element_text(size = 14),  # Increased y-axis text size
        axis.title.y = element_text(size = 16),  # Increased y-axis label size
        legend.position = "top",
        legend.text = element_text(size = 12),  # Increased legend text size
        title = element_text(size = 16)) +  # Increased title size
  scale_fill_manual(values = c("KR_Patient" = "#F2300F", 
                              "NonKR_Patient" = "#972D15",
                              "Healthy" = "#D8B70B")) +
  scale_color_manual(values = c("KR_Patient" = "#F2300F", 
                               "NonKR_Patient" = "#972D15",
                               "Healthy" = "#D8B70B")) +
  labs(x = "", y = "Log2 CPM",
       title = "APOBEC Expression Levels")
 # +stat_compare_means(aes(group = Group), 
  #                  method = "wilcox.test",
   #                 label = "p.signif",
    #                label.y = max(apobec_long$Expression) + 0.5)

# Save the plot
ggsave("../ch2/shuaib/apobec_expression_barplot.pdf", width = 10, height = 6)


```

```{r}
# Create a named vector to map Ensembl IDs to symbols
gene_symbols <- tt_apobecs$SYMBOL
names(gene_symbols) <- tt_apobecs$ID

# Extract APOBEC expression values
apobec_data <- lcpm[i,] %>% 
  as.data.frame() %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Sample") %>%
  mutate(Group = study$Class) 

# Reshape to long format and replace Ensembl IDs with symbols
apobec_long <- apobec_data %>%
  pivot_longer(cols = -c(Sample, Group),
              names_to = "Gene",
              values_to = "Expression") %>%
  mutate(Gene = gene_symbols[Gene])  # Replace IDs with symbols

# First modify the Group values in the data
apobec_long <- apobec_long %>%
  mutate(Group = case_when(
    Group == "KR_Patient" ~ "Severe",
    Group == "NonKR_Patient" ~ "Mild",
    TRUE ~ as.character(Group)
  ))

# Create the plot with renamed groups
ggplot(apobec_long, aes(x = Gene, y = Expression, fill = Group)) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(0.8), alpha = 0.5) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8),
              aes(color = Group), size = 2) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.y = element_text(size = 16),
        legend.position = "top",
        legend.text = element_text(size = 12),
        title = element_text(size = 16)) +
  scale_fill_manual(values = c("Severe" = "#F2300F", 
                              "Mild" = "#972D15",
                              "Healthy" = "#D8B70B")) +
  scale_color_manual(values = c("Severe" = "#F2300F", 
                               "Mild" = "#972D15",
                               "Healthy" = "#D8B70B")) +
  labs(x = "", y = "Log2 CPM",
       title = "APOBEC Expression Levels")
  # stat_compare_means(aes(group = Group), 
  #                  method = "wilcox.test",
  #                  label = "p.signif",
  #                 label.y = max(apobec_long$Expression) + 0.5)
# Save the plot
ggsave("../ch2/shuaib/apobec_expression_barplot_renamed_with_stats.pdf", width = 10, height = 6)
library(rstatix)

# Perform statistical tests for each gene
stats_results <- apobec_long %>%
  group_by(Gene) %>%
  wilcox_test(Expression ~ Group) %>%
  adjust_pvalue(method = "bonferroni") %>%
  add_significance() %>%
  select(Gene, group1, group2, n1, n2, statistic, p, p.adj, p.adj.signif)

# Save statistics to CSV
write.csv(stats_results, "../ch2/shuaib/apobec_statistics.csv", row.names = FALSE)
```


## Heatmap of cytokines

```{r}
save_pheatmap_pdf <- function(x, filename, width=8, height=4) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}

lcpm <- edgeR::cpm(norm, log=TRUE)

tt_cytokines <- read.csv("~/Desktop/phd/Thesis/ch2/Cytokine_Genes_Analysis.csv")

#tt_cytokines <- dplyr::filter(tt, cytokines$SYMBOL)

topTable.topgenes <- tt_cytokines$ID
i <- which(vm$genes$ENSGID %in% topTable.topgenes)
mycol <- colorRampPalette(c("blue","white","red"))(20)

#annotation info
annotation <- data.frame(seq(1:102),study$Class, row.names = 1)
colnames(annotation) <- gsub("study.", "", colnames(annotation))
rownames(annotation) <- colnames(lcpm) # check out the row names of annotation
##colors

ann_colors = list(
    ICU = c(KR_Patient="#F2300F", NonKR_Patient="#972D15", Healthy ="#D8B70B"))

heatmap1 <- pheatmap(lcpm[i,], cluster_cols = F, cluster_rows = T,
                     scale = "row", #kmeans_k = 20,
                     cutree_rows = 2, cutree_cols = 2,
                     color = colorRampPalette(c("blue", "white", "red"))(20),
                     show_rownames = 1, annotation_col = annotation, 
                     cellwidth = 7, cellheight = 7, border_color = "black",
                     labels_col=study$ID, annotation_colors = ann_colors,
                     treeheight_row=0, labels_row = vm$genes$SYMBOL[i],
                     fontsize = 7, legend = FALSE, annotation_legend = FALSE
                     )

pdf(file="~/Desktop/phd/Thesis/ch2/shuaib/heatmap_cytokines.pdf", height=12, width=13)
heatmap1
dev.off()

```

## Pathway analysis
```{r}
library(clusterProfiler)

cluster1_larger <- dplyr::filter(two_clusters, two_clusters=="1")
cluster1_genes <- cluster1_larger$ID

cluster1 <- enrichGO(
  keyType = "ENSEMBL",
  gene = cluster1_genes,
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE)

cluster2_smaller <- dplyr::filter(two_clusters, two_clusters=="2")
cluster2_genes <- cluster2_smaller$ID

cluster2 <- enrichGO(
  keyType = "ENSEMBL",
  gene = cluster2_genes,
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE)
#keytypes(org.Hs.eg.db)

# Select specific pathways

#selected_pathways_cluster1 <- c("leukocyte chemotaxis","mononuclear cell differentiation","phagocytosis","myeloid leukocyte migration","cellular response to biotic stimulus","neutrophil migration","T cell differentiation","regulation of inflammatory response","positive regulation of protein serine/threonine kinase activity","regulation of interleukin-6 production","toll-like receptor signaling pathway","interleukin-6 production","maintenance of location","regulation of cell morphogenesis","Ras protein signal transduction","regulation of small GTPase mediated signal transduction","B cell activation","positive regulation of GTPase activity","regulation of leukocyte mediated immunity","regulation of cell shape")
#selected_pathways_cluster2 <- cluster2$Description[1:20][-c(16:17)]

write.csv(cluster1@result, "~/Desktop/phd/Thesis/ch2/shuaib/clusterProfiler_cluster1.csv")
write.csv(cluster2@result, "~/Desktop/phd/Thesis/ch2/shuaib/clusterProfiler_cluster2.csv")

p1 <- dotplot(cluster1, showCategory = 20 ) + viridis::scale_fill_viridis()
p2 <- dotplot(cluster2, showCategory = 20 ) + viridis::scale_fill_viridis()

pdf(file="~/Desktop/phd/Thesis/ch2/shuaib/clusterProfiler_heatmapClusters_selected.pdf", height=10, width=13)
cowplot::plot_grid(p1, p2, ncol=2) 
dev.off()
```


```{r}
dna <- read.table("Hypermethylated.txt", sep = "\t", header = TRUE)

hyper<- unique(dna$Hyper)
hypo<-unique(dna$Hypo)

hyper_plot <- enrichGO(
  keyType = "ENSEMBL",
  gene = hyper,
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE)

hypo_plot <- enrichGO(
  keyType = "ENSEMBL",
  gene = hypo,
  OrgDb         = org.Hs.eg.db,
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE)


p3 <- dotplot(hyper_plot, showCategory = 30) + viridis::scale_fill_viridis()
p4 <- dotplot(hypo_plot, showCategory = 30) + viridis::scale_fill_viridis()

pdf(file="clusterProfiler_DNAm_heatmapClusters.pdf", height=10, width=13)
cowplot::plot_grid(p3, p4, ncol=2) 
dev.off()

```


```{r}
metascape_results <- read.csv("pathway/cluster1_bigger/Enrichment_GO/_FINAL_GO.csv")

data <- read.csv("~/Desktop/S1.csv", header = TRUE, stringsAsFactors = FALSE)
S1<- ggplot(data, aes(x= Group, y=Pathways, size=DEGs, color=FDR, group=Group)) + geom_point(alpha = 0.8) + 
theme_classic()
S1 

S1 = S1+scale_color_gradient(low = "red2",  high = "mediumblue", space = "Lab", limit = c(0.000000000000000007, 0.002))
S1+scale_size(range = c(2, 8))
S1

```

## GeneSetCluster
```{r}
install_github("TranslationalBioinformaticsUnit/GeneSetCluster")
source('/Library/Frameworks/R.framework/Versions/4.1/Resources/library/GeneSetCluster/R/BreakUpCluster.R')


RNA_up_sig1 <- read.csv("~/Desktop/dnam/rnaseq/pathway/up_sig1/Enrichment_GO/_FINAL_GO.csv", header = TRUE)
RNA_dowd_sig1 <- read.csv("~/Desktop/dnam/rnaseq/pathway/down_sig1/Enrichment_GO/_FINAL_GO.csv", header = TRUE)

DNA_hypo <- read.csv("~/Desktop/dss/73samples/hypo_dss_73/Enrichment_GO/_FINAL_GO.csv", header = TRUE)
DNA_hyper <-read.csv("~/Desktop/dss/73samples/hyper_dss_73/Enrichment_GO/_FINAL_GO.csv", header = TRUE)

# Gene-Sets with a pvalue < 0.05 (aka -log10(pvalue) > 1.31) and more than 5 molecules
RNA_up_sig1_filtered <- RNA_up_sig1[RNA_up_sig1$LogP < -1.31 & RNA_up_sig1$X.GeneInGOAndHitList > 5,]
DNA_hypo_filtered <- DNA_hypo[DNA_hypo$LogP < -1.31 & DNA_hypo$X.GeneInGOAndHitList > 5,]

nrow(RNA_up_sig1) #3280
nrow(RNA_up_sig1_filtered) #2674
nrow(DNA_hypo) #459
nrow(DNA_hypo_filtered) #325
#We can see that we have 53 Gene-Sets which are significant according to our definition.
# Object creator
RNAupVSDNAhypo.PathwayObject <- ObjectCreator(Pathways = c(RNA_up_sig1_filtered$Description,
                                                       DNA_hypo_filtered$Description), 
                                          Molecules = c(RNA_up_sig1_filtered$Hits,
                                                       DNA_hypo_filtered$Hits),
                                          Groups = c(rep("RNA_up", times = nrow(RNA_up_sig1_filtered)),
                                                     rep("DNA_hypo", times = nrow(DNA_hypo_filtered))),
                                          Source = "Metascape",
                                          Type = "Test",#Optional
                                          structure = "SYMBOL",
                                          organism ="org.Hs.eg.db",
                                          sep = "|")

```

### Harmonize and Cluster
```{r}

man.Great.Object2 <- CombineGeneSets(Object = RNAupVSDNAhypo.PathwayObject,
                                     combineMethod = "Jaccard")

OptimalGeneSets(object = man.Great.Object2, method = "silhouette", max_cluster= 8, cluster_method = "kmeans", main= "Kmeans for 10 clusters")


ShowExperimentdata(Object =man.Great.Object2 )
ShowMeta(Object = man.Great.Object2 )

man.Great.Object3 <- BreakUpCluster(Object = man.Great.Object3, breakup.cluster = 3, sub.cluster=3)   


man.Great.Object3 <- ClusterGeneSets(Object = man.Great.Object2, 
                                 clusters = 2, 
                                 method = "kmeans")


PlotGeneSets(Object =man.Great.Object3)

```
### Highligting gene clusters
```{r}
IPA.object1 <- LoadGeneSets(file_location = canonical.files,
                         groupnames= c("KO", "WT"),
                         P.cutoff = 1.3,
                         Mol.cutoff = 5,
                         Source = "IPA",
                         type = "Canonical_Pathways",
                         structure = "SYMBOL",
                         seperator = ",")
IPA.object2 <- CombineGeneSets(Object = IPA.object1)

IPA.object3 <- ClusterGeneSets(Object = IPA.object2,
                              clusters = 12,
                              method = "kmeans")
system.file("data", "Redox.genes.rda", package = "testdat")
IPA.object3.highlight <- HighlightGeneSets(Object = IPA.object3,
                                          highligt.genes = Redox.genes,
                                          name = "Ros")

PlotGeneSets(IPA.object3.highlight)
 
```


## Cell deconvolution
### Data preparation
```{r}
#split the dataset into half 31662/2 = 15830 cells + 1 header;
# 33 samples: 16 control + 17 COVID
# in terminal
# cut -f -15831 raw_counts_scrna.txt > new_raw_counts_scrna.txt 
# 32871 x 15829
# 32871  6198 only covid mild vs severe

# shift column names to the right by one
a1<-read.table("~/Downloads/tail.txt", header=T)
a1$new <- "" 
names(a1)[1:ncol(a1)] <- c("barcode_id", names(a1)[1:ncol(a1) - 1])

write.table(a1, "new_raw_counts_scrna.txt", row.names = F, quote = F, sep = "\t")
```

```{r}
devtools::install_github('xuranw/MuSiC')
# load
library(MuSiC)

a1<-

ExpressionSet()

a1<- read.csv("~/Desktop/dnam/rnaseq/data/raw_pool1_2.csv", row.names = 1)
ensg <- sub("\\..*", "", rownames(a1))  # remove version number in case you have it
sym <- AnnotationDbi::mapIds(EnsDb.Hsapiens.v86, keys=ensg,
        column="SYMBOL", keytype="GENEID") # Unable to map 3533 of 60663 requested IDs.
gene <- data.frame(ENSGID=ensg, SYMBOL=sym, stringsAsFactors=F)
rownames(gene) <- rownames(a1)
rownames(a1) <- gene$SYMBOL
a2<-data.frame(gene, a1)
a2<-a2[,-1]
dim(a2) #60664    33
a2<-a2[complete.cases(a2), ]
dim(a2) #57131    33
a3<-a2[!duplicated(a2$SYMBOL), ] #55418    33

rownames(a2) <- a2$SYMBOL
a2<-a2[,-1]
getwd()
write.table(a2, "data/deconvolution/raw_bulk_new.txt", quote = F, sep = "\t")

a4<-read.csv("data/meta_updated.csv", row.names = 1)
a5<-read.table("data/deconvolution/music.txt", sep = "\t", header = T, row.names = 1)
write.csv(merge(a4, a5, by = 0), "meta_deconvolution.csv")
a6<-read.csv("data/deconvolution/heatmap_deconvolution.csv", row.names = 1)
tA6<-as.data.frame(t(a6))
a7 <- subset(tA6, rowSums(tA6) > 0.001)

save_pheatmap_pdf <- function(x, filename, width=9, height=9) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}
mycol <- colorRampPalette(c("blue","white","red"))(20)

#annotation info
annotation <- data.frame(study$ID, study$Comorbidities, study$Outcome,
                         study$Age, study$Hospital, study$ICU, row.names = 1)
colnames(annotation) <- gsub("study.", "", colnames(annotation))
rownames(annotation) <- colnames(lcpm) # check out the row names of annotation
##colors
Comorbidities_col <- as.character(wes_palette("Rushmore1", # color palette for the synergy 
                                   type = "continuous"))
names(Comorbidities_col) <- unique(study$Comorbidities)

ICU_col <- as.character(wes_palette("Cavalcanti1",  
                                   length(unique(study$ICU)), 
                                   type = "continuous"))
names(ICU_col) <- unique(study$ICU)
Outcome_col <- as.character(wes_palette("Cavalcanti1",  
                                   length(unique(study$Outcome)), 
                                   type = "continuous"))
names(Outcome_col) <- unique(study$Outcome)
Age_col <- as.character(wes_palette("IsleofDogs2",  
                                   40, 
                                   type = "continuous"))
names(Age_col) <- unique(study$Age)
Hospital_col <- as.character(wes_palette("Chevalier1",  
                                   length(unique(study$Hospital)), 
                                   type = "continuous"))
names(Hospital_col) <- unique(study$Hospital)

ann_colors = list(
    ICU = ICU_col,
    Comorbidities = c(None="#E1BD6D", One="#9FA682", Two="#274150", Three="#F2300F"),
    Outcome = Outcome_col,
    Age = Age_col,
    Hospital = Hospital_col
)

heatmap_deconv <- pheatmap::pheatmap(a7, cluster_cols = T, cluster_rows = T,
                     #scale = "row", #kmeans_k = 20,
                     cutree_rows = 2, cutree_cols = 2,
                     color = mycol,
                     show_rownames = 1, #annotation_col = annotation, 
                     cellwidth = 8, cellheight = 8, border_color = "black",
                     #labels_col= row.names(a6), #annotation_colors = ann_colors,
                     treeheight_row=2, treeheight_col = 3
                     )
save_pheatmap_pdf(heatmap_deconv, "heatmap_deconv.pdf")
```


# DNAm heatmap based on RNAseq

```{r}
## DNAm heatmap

# 1. Impute NA values.
# 2. Select DML's perc methylation
# 3. Make a heatmap on them using pheatmap

library(pheatmap)
library(Polychrome)
library(dplyr)

cts<-read.csv("~/Desktop/dnam/analysis/methylKit/perc_methylation_significant/coords.csv", row.names = 1, header = T)
drops <- c("ICU_02","ICU_05","ICU_06","ICU_07","ICU_10","ICU_12","ICU_13","ICU_14","ICU_15","ICU_19","ICU_20","ICU_21","ICU_23","ICU_24","ICU_29","ICU_30","ICU_31","ICU_33","ICU_34","ICU_35","ICU_38","ICU_39","ICU_42","ICU_43","ICU_48","ICU_50","ICU_51","ICU_54","ICU_58","ICU_60","ICU_61","ICU_62","ICU_64","ICU_66","ICU_68","NON_01","NON_10","NON_12","NON_14","NON_15","NON_18","NON_20","NON_22","NON_23","NON_31")


cts <- cts[, !(names(cts) %in% drops)]
# dim is 60664 x 81
rownames_cts <- row.names(cts)
study<-read.csv("~/Desktop/rnaseq/last/meta_dna_based_on_RNAseq.csv", header = T, row.names = 1)
study <- study[!(rownames(study) %in% drops),]
col_by_icu <- row.names(study)
cts <- cts[col_by_icu]

stopifnot( identical( colnames(cts), rownames(study) ) )

#annotation info
annotation <- data.frame(study$AltName, study$Comorbidities, study$Age,
                         study$Hospital, study$Outcome, study$ICU, row.names = 1)
colnames(annotation) <- gsub("study.", "", colnames(annotation))
rownames(annotation) <- colnames(cts) # check out the row names of annotation
##colors
Comorbidities_col <- as.character(wes_palette("Rushmore1", # color palette for the synergy 
                                              type = "continuous"))
names(Comorbidities_col) <- unique(study$Comorbidities)

ICU_col <- as.character(wes_palette("Cavalcanti1",  
                                    length(unique(study$ICU)), 
                                    type = "continuous"))
names(ICU_col) <- unique(study$ICU)
Outcome_col <- as.character(wes_palette("Cavalcanti1",  
                                        length(unique(study$Outcome)), 
                                        type = "continuous"))
names(Outcome_col) <- unique(study$Outcome)
Age_col <- as.character(wes_palette("IsleofDogs2",  
                                    40, 
                                    type = "continuous"))
names(Age_col) <- unique(study$Age)
Hospital_col <- as.character(wes_palette("Chevalier1",  
                                         length(unique(study$Hospital)), 
                                         type = "continuous"))
names(Hospital_col) <- unique(study$Hospital)

batch_col <- as.character(glasbey.colors(13))
names(batch_col) <- unique(study$Batch)

ann_colors = list(
  ICU = ICU_col,
  Comorbidities = c(None="#E1BD6D", One="#9FA682", Two="#274150", Three="#F2300F"),
  Outcome = Outcome_col,
  Age = Age_col,
  Hospital = Hospital_col
  #Batch = batch_col
)

save_pheatmap_pdf <- function(x, filename, width=9, height=13) {
  stopifnot(!missing(x))
  stopifnot(!missing(filename))
  pdf(filename, width=width, height=height)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}

heatmap2<- pheatmap(cts, show_rownames = 0, annotation_col = annotation, cluster_cols =F,
                    cluster_rows = T, annotation_colors = ann_colors, treeheight_row=0,
                    scale = "none", color = colorRampPalette(c("blue", "white", "red"))(20))

save_pheatmap_pdf(heatmap2, "~/Desktop/rnaseq/last/Heatmap_annotation_dnam_28.pdf")

```



